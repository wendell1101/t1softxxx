<?php

use \League\OAuth2\Server\Repositories\ClientRepositoryInterface;

class PlayerClientRepository implements ClientRepositoryInterface{

	/**
	 * The client model repository.
	 *
	 */
	// protected $clients;

	private $player_oauth2_model;
	private $CI;
	private $utils;

	/**
	 * Create a new repository instance.
	 *
	 * @return void
	 */
	public function __construct($CI, $player_oauth2_model)
	{
		$this->player_oauth2_model=$player_oauth2_model;
		$this->CI=$CI;
		$this->utils=$this->CI->utils;
		// $this->clients = $clients;
	}

	/**
	 * {@inheritdoc}
	 */
	public function getClientEntity($clientIdentifier, $grantType, $clientSecret = null, $mustValidateSecret = true)
	{
		if($mustValidateSecret){
			if(!$this->validateClient($clientIdentifier, $clientSecret, $grantType)){
				return null;
			}
		}
		//get client record from db
		$client=$this->player_oauth2_model->queryClientById($clientIdentifier);
		if(empty($client)){
			return null;
		}
		return new PlayerClientEntity(
		    $clientIdentifier,
		    $client['name'],
		    $client['redirect'],
		    $client['confidential'],
		    $client['provider']
		);

		// $record = $this->clients->findActive($clientIdentifier);

		// if (! $record) {
		//     return;
		// }

		// return new PlayerClientEntity(
		//     $clientIdentifier,
		//     $record->name,
		//     $record->redirect,
		//     $record->confidential(),
		//     $record->provider
		// );
	}

	/**
	 * {@inheritdoc}
	 */
	public function validateClient($clientIdentifier, $clientSecret, $grantType)
	{
		//query db
		$client=$this->player_oauth2_model->queryActiveClient($clientIdentifier);
		$this->utils->debug_log('id', $clientIdentifier, 'grantType', $grantType, $client);
		if (empty($client) || ! $this->handlesGrant($client, $grantType)) {
		    return false;
		}

		return ! $client['confidential'] || $this->verifySecret((string) $clientSecret, $client['secret']);

		// First, we will verify that the client exists and is authorized to create personal
		// access tokens. Generally personal access tokens are only generated by the user
		// from the main interface. We'll only let certain clients generate the tokens.
		// $record = $this->clients->findActive($clientIdentifier);

		// if (! $record || ! $this->handlesGrant($record, $grantType)) {
		//     return false;
		// }

		// return ! $record->confidential() || $this->verifySecret((string) $clientSecret, $record->secret);
	}

	/**
	 * Determine if the given client can handle the given grant type.
	 *
	 * @param  array  $record
	 * @param  string  $grantType
	 * @return bool
	 */
	protected function handlesGrant($client, $grantType)
	{
		if (is_array($client['grant_types']) && ! in_array($grantType, $client['grant_types'])) {
			return false;
		}

		switch ($grantType) {
			case 'authorization_code':
				return ! $client['firstParty'];
			case 'personal_access':
				return $client['personal_access_client'] && $client['confidential'];
			case 'password':
				return $client['password_client'];
			case 'client_credentials':
				return $client['confidential'];
			case 'refresh_token':
				return true;
			default:
				return true;
		}
	}

	/**
	 * Verify the client secret is valid.
	 *
	 * @param  string  $clientSecret
	 * @param  string  $storedHash
	 * @return bool
	 */
	protected function verifySecret($clientSecret, $storedHash)
	{
		return hash_equals($storedHash, $clientSecret);
	}
}
